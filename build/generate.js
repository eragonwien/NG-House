/**
 * This script generates data based on user input
 * 
 * 1. let the user choose which data are going to be generated 
 * 2. check if letiables for test generation is available. if not, abort
 * 3. ask the user to input how many data are going to be generated. user can abort from here.
 * 4. count the current number of data
 * 5. generate data base from the input
 * 6. count the number of generated data
 * 
 * Following test data can be generated:
 * address is generated from ADDRESS, POSTAL_CODE, CITY and LAND
 * 
 * user is generated from NAME. email is firstname_lastname_time@lastname.com
 * for address, all address ids are queried and is randomly chosen.
 * role is always standard which has id of 1
 * 
 * house is generated by querying user , type, address and currency
 * a type is randomly chosen. base on type a specific ranges are generated
 * apartment: 20 - 100m, 1-2 bathrooms, 1-2 bedrooms
 * house: 100 - 500, 1-2 bathrooms, 1-4 bedrooms
 * villa : 500 - 1000, 1-5 bathrooms, 1-5 bedrooms
 * others: min 20 - max. 1000, 1-2 bathrooms, 1-2 bedrooms
 * price = (2000 - 5000) * size
 */

let readline = require('readline-sync');
let dotenv = require('dotenv');
let fs = require('fs');
let helper = require('./helper');
let pool = require('../backend/config/db').pool;
let supportedTypes = ['address', 'user', 'house', 'admin', 'bookmark'];

let addressModel = require('../backend/components/address/addressModel');
let userModel = require('../backend/components/user/userModel');
let houseModel = require('../backend/components/house/houseModel');
let bookmarkModel = require('../backend/components/bookmark/bookmarkModel');


start();

// start the data generation
function start() {
    setupGeneration();
}

// gets user commands and checking requirements
function setupGeneration() {
    let type = getDataType();
    if (!type) {
        return finish('This data type is not supported.');
    }
    let count = getDataCount();

    checkRequirements(function (error) {
        if (error) {
            return finish(error);
        }
        startGeneration(type, count);
    });
}

/**
 * get data type from user input
 * @returns {string} name of the type
 */
function getDataType() {
    console.log('Supported types: ' + supportedTypes.toString());
    let type = readline.question('Which type is going to be generated ? ');
    type = (supportedTypes.includes(type)) ? type : null;
    return type;
}

/**
 * get data count from user input
 * @returns {number} number of data to be generated
 */
function getDataCount() {
    let count = readline.questionInt('How many data should be generated: ');
    if (count < 0) {
        console.log('The number cannot be smaller than zero. Please try again.');
        return getDataCount();
    }
    return count;
}

/**
 * checks if requirements are met,
 * if not, includes error in callback function
 * @param {function} done callback function
 */
function checkRequirements(done) {
    let path = '.env';
    fs.exists(path, function (fileIsExist) {
        if (!fileIsExist) {
            return done('File .env not found. Please run this first: npm run build');
        }
        done();
    });
}

/**
 * checks if the .env file exists 
 * the user is asked for the number of data which are going to be generated
 * @param {string} type The type of the data
 */
function prepareGenerating(type) {
    let path = '.env';
    fs.exists(path, function (fileIsExist) {
        if (!fileIsExist) {
            return console.log('File .env not found. Abort.');
        }
        let count = readline.questionInt('How many data should be generated: ');
        if (count < 0) {
            console.log('The number cannot be smaller than zero. Please try again.')
            return prepareGenerating(type);
        }
        generateData(type, count);
    });
}
/**
 * pass data to generation function
 * @param {string} type type of the generated data
 * @param {number} count number of the data
 */
function startGeneration(type, count) {
    switch (type) {
        case 'house':
            generateHouse(count);
            break;
        case 'user':
            generateUser(count, false);
            break;
        case 'admin':
            generateUser(count, true);
            break;
        case 'address':
            generateAddress(count);
            break;
        case 'bookmark':
            generateBookmark(count);
            break;
        
        default: console.log('Unsupported Type.');
            break;
    }
}

/**
 * generates user
 * first checks if the .env file has letiable NAME, cancel process if not
 * query all address ids 
 * create queries to add user to the database
 * @param {number} count number of user being generated
 * @param {boolean} isAdmin true if admins are to be generated
 */
function generateUser(count, isAdmin) {
    if (!process.env.NAME) {
        return finish(null, 'no NAME letiables found.');
    }
    let names = helper.getListFromString(process.env.NAME);
    let addressModel = require('../backend/components/address/addressModel');
    addressModel.getAllAddresses(function (error, results) {
        if (error) {
            return console.log(error);
        } 
        // extract only the address id from the results
        let address_ids = helper.filterValuesOfList(results, 'id');
        if (isAdmin) {
            return spawnAdmins(count, names, address_ids);
        }
        spawnUsers(count, names, address_ids); 
    });
    
}

/**
 * generate users
 * @param {number} count number of users to be generated
 * @param {string[]} names list of names
 * @param {string[]} addressList list of addresses
 * @param {string[]} successCount number of successful query
 */
function spawnUsers(count, names, addressList, successCount) {
    if (!successCount) {
        successCount = 0;
    }
    if (count <= 0) {
        return finish(null, 'Success: ' + successCount);
    }
    // generates an user object
    let first_name = names[helper.getRandomInt(names.length)];
    let last_name = names[helper.getRandomInt(names.length)];
    let randomValue = helper.getRandomInt(1000);
    let username = first_name + last_name + randomValue;
    let user = {
        first_name: first_name,
        last_name: last_name,
        username: username,
        password: 'test',
        email: username + '@' + last_name + '.com',
        role_id: 1,
        address_id: addressList[helper.getRandomInt(addressList.length)]
    }
    // insert query
    userModel.createUser(user, function (error, result) {
        successCount = (error) ? successCount : successCount + 1;
        count--;
        spawnUsers(count, names, addressList, successCount);
    });
}

/**
 * generate admins
 * @param {number} count number of admins to be generated
 * @param {string[]} names list of names
 * @param {string[]} addressList list of addresses
 * @param {string[]} successCount number of successful query
 */
function spawnAdmins(count, names, addressList, successCount) {
    if (!successCount) {
        successCount = 0;
    }
    if (count <= 0) {
        return finish(null, 'Success: ' + successCount);
    }
    // generates an user object
    let first_name = names[helper.getRandomInt(names.length)];
    let last_name = names[helper.getRandomInt(names.length)];
    let randomValue = helper.getRandomInt(1000);
    let username = first_name + last_name + randomValue;
    let user = {
        first_name: first_name,
        last_name: last_name,
        username: username,
        password: 'test',
        email: username + '@' + last_name + '.com',
        role_id: 2,
        address_id: addressList[helper.getRandomInt(addressList.length)]
    }
    // insert query
    userModel.createUser(user, function (error, result) {
        successCount = (error) ? successCount : successCount + 1;
        count--;
        spawnAdmins(count, names, addressList, successCount);
    });
}

/**
 * generates addresses
 * @param {number} count number of addresses
 */
function generateAddress(count) {
    if (!process.env.NAME) {
        return finish(null, 'no NAME letiables found.');
    }
    // set postal code length as 4 if no value in .env found
    let postalCodeLength = (process.env.POSTAL_CODE) ? process.env.POSTAL_CODE : 4;
    let names = helper.getListFromString(process.env.NAME);
    // spawn addresses
    spawnAddresses(count, names, postalCodeLength)
}

/**
 * spawns recursively addresses
 * @param {number} count number of addresses
 * @param {string[]} names list of names
 * @param {number} postalCodeLength length of the random postal code
 * @param {number} successCount number of successful actions
 */
function spawnAddresses(count, names, postalCodeLength, successCount) {
    if (!successCount) {
        successCount = 0;
    }
    if (count <= 0) {
        return finish(null, 'Success: ' + successCount);
    }
    // generate an address object
    let address = {
        address: names[helper.getRandomInt(names.length)] + 'Street ' + helper.getRandomInt(100),
        postal_code: helper.getRandomInt(Math.pow(10, postalCodeLength - 1), Math.pow(10, postalCodeLength)),
        city: names[helper.getRandomInt(names.length)] + ' City',
        land: names[helper.getRandomInt(names.length)] + ' Land'
    }
    // insert query
    addressModel.createNewAddress(address, function (error, result) {
        successCount = (error) ? successCount : successCount + 1;
        count--;
        spawnAddresses(count, names, postalCodeLength, successCount);
    });
}

/**
 * generates houses
 * @param {number} count number of houses 
 */
function generateHouse(count) {
    
    Promise.all([helper.getAllUsers(), helper.getAllHouseTypes(), helper.getAllAddresses(), helper.getAllCurrencies()]).then(promiseSuccess).catch(promiseError)

    function promiseSuccess(values) {
        let userIds = values[0], houseTypeIds = values[1], addressIds = values[2], currencyIds = values[3];
        spawnHouses(count, userIds, houseTypeIds, addressIds, currencyIds);
    }

    function promiseError(error) {
        finish(error);
    }
}

/**
 * generates houses recursively
 * @param {number} count number of houses to be generated
 * @param {number[]} userIds list of all user ids
 * @param {number[]} houseTypeIds list of all type ids
 * @param {number[]} addressIds list of all address ids
 * @param {number[]} currencyIds list of all currency ids 
 * @param {number} successCount number of successful inserts
 * house is generated by querying user , type, address and currency
 * a type is randomly chosen. base on type a specific ranges are generated
 * size: min 20 - max. 1000, 1-2 bathrooms, 1-2 bedrooms
 * price = (2000 - 5000) * size
 */
function spawnHouses(count, userIds, typeIds, addressIds, currencyIds, successCount) {
    if (!successCount) {
        successCount = 0;
    }
    if (count <= 0) {
        return finish(null, 'Success: ' + successCount);
    }
    // create house
    let bathrooms = helper.getRandomInt(1, 5);
    let bedrooms = helper.getRandomInt(1, 5);
    let rooms = bathrooms + bedrooms + helper.getRandomInt(1, 3);
    let size = helper.getRandomInt(rooms * 10, rooms * 100);
    let price = helper.getRandomInt(200, 1000) * size;
    let house = {
        price: price,
        rooms : rooms,
        bathrooms: bathrooms,
        bedrooms: bedrooms,
        size: size,
        user_id: userIds[helper.getRandomInt(userIds.length)],
        address_id: addressIds[helper.getRandomInt(addressIds.length)],
        house_type_id: typeIds[helper.getRandomInt(typeIds.length)],
        house_status_id: 1, 
        currency_id: currencyIds[helper.getRandomInt(currencyIds.length)],
    };
    houseModel.createHouse(house, function (error, result) {
        successCount = (error) ? successCount : successCount + 1;
        count--;
        spawnHouses(count, userIds, typeIds, addressIds, currencyIds, successCount);
    });
}


/**
 * generates bookmarks
 * first checks if the .env file has letiable NAME, cancel process if not
 * query all user and house ids 
 * @param {number} count number of user being generated
 * @param {boolean} isAdmin true if admins are to be generated
 */
function generateBookmark(count) {
    if (!process.env.NAME) {
        return finish(null, 'no NAME letiables found.');
    }
    let names = helper.getListFromString(process.env.NAME);
    Promise.all([helper.getAllUsers(), helper.getAllHouses()]).then(promiseSuccess).catch(promiseError);

    function promiseSuccess(results) {
        let userIds = results[0];
        let houseIds = results[1];
        spawnBookmarks(count, userIds, houseIds);
    }
    
    function promiseError(error) {
        finish(error);
    }
}

/**
 * generate bookmarks
 * @param {number} count number of users to be generated
 * @param {string[]} userIds list of user ids
 * @param {string[]} houseIds list of house ids
 * @param {string[]} successCount number of successful query
 */
function spawnBookmarks(count, userIds, houseIds, successCount) {
    if (!successCount) {
        successCount = 0;
    }
    if (count <= 0) {
        return finish(null, 'Success: ' + successCount);
    }

    let bookmark = {
        user_id: userIds[helper.getRandomInt(userIds.length)],
        house_id: houseIds[helper.getRandomInt(houseIds.length)]
    }

    bookmarkModel.createBookmark(bookmark, function (error, result) {
        successCount = (error) ? successCount : successCount + 1;
        count--;
        spawnBookmarks(count, userIds, houseIds, successCount);
    });
}

/**
 * closes the process
 * @param {string} error error message
 * @param {?string} message console message
 */
function finish(error, message) {
    if (error) {
        console.error(error);
    }
    if (message) {
        console.log(message);
    }
    process.exit();
}




